# 第1章
## 方法
当本书作者第一次开始学习C，以及后来的C++时，他常常写一些简短的代码，编译它们，然后查看汇编形式的输出。这使得他很容易理解他写的代码要做什么[1]。他做了很多次，所以C/C++代码和编译器结果之间的关系深深印在了他的脑海里。很容易立刻想象到C代码外貌的轮廓和功能。可能这种方法也可以帮助别人。

有时为了得到尽可能短(或者简单)的代码片段，这里要用到一些陈旧的编译器。

## 练习
当本书作者学习汇编语言是，他也经常编译一些小的C函数，然后将逐渐将它们用汇编重写，尽可能的使它们简短。在现在的真实世界场景下，这样做可能不值得，因为就效率而言，无法与现代编译器相比。但是，这是一种更好地理解汇编的好方法。所以，随意使用本书中的汇编代码并缩短它。但别忘了测试你写的代码。

## 优化级别和调试信息
源代码可以被不同的编译器使用不同的优化等级编译。典型的编译器大约有3个这样的等级。0级意味着禁用优化。优化的目的可以是代码大小或代码速度。一个没有优化的编译器更快，产生更易理解(尽管冗长)的代码，然而一个优化的编译器更慢并且尝试产生允许运行更快(但未必更紧凑)的代码。包括优化级别和方向，一个编译器在结果文件中包含一些调试信息，因此产生易于调试的代码。调试代码的一个重要特征是它可能含有源代码的每一行与各自机器代码地址的联系。另一方面，优化的编译器趋向于产生源代码的全部行都被优化，所以机器代码中没有展示的结果。你像工程师会遇到任何一个版本，仅仅是因为一些开发人员开启了编译器优化标志，而其他的开发人员不这么做。因此，我们会尝试本书中调试和发型版的代码。

[1] 事实上，当他无法理解一个特定比特的代码做了什么的时候，他也会做这个。
